# -*- coding: utf-8 -*-
"""
Use this file as an template for your project 2
"""
import numpy as np
import cvxpy as cp
import math
from random import shuffle




    

def generator(n, prob_inf, T):
    
    
    ppl = np.random.binomial(size=n, n=1, p= prob_inf)    # ppl is the population
    
    
    col_weight = math.ceil(math.log(2)*T/(n*prob_inf))
    X = np.zeros((T,n))
    X[0:col_weight,:] = 1
    idx = np.random.rand(*X.shape).argsort(0)
    X = X[idx, np.arange(X.shape[1])]
    y_temp = X@ppl #result vector
    y = np.ones_like(y_temp)*(y_temp>=1) #test results
    
    return X, ppl, y #return population and test results

def generator_nonoverlapping(n, q, p, m, T):
    
    ppl = np.zeros(n)    # ppl is the population
    A = np.zeros((m,n)) #family structure matrix
    A[0:1,:] = 1
    idx = np.random.rand(*A.shape).argsort(0)
    A = A[idx, np.arange(A.shape[1])]
    
    inf_families = np.random.binomial(size=m, n=1, p= q)
    
    for i in range(m):
        if inf_families[i] == 1:     #check if family is infected
            indices = A[i,:] == 1    #find the family members
            binom = np.random.binomial(size=np.sum(indices),n=1, p=p)
            ppl[indices] = (ppl[indices] + binom)>0
    
    
    col_weight = math.ceil(math.log(2)*T/(n*q*p)) 
    X = np.zeros((T,n))
    X[0:col_weight,:] = 1
    idx = np.random.rand(*X.shape).argsort(0)
    X = X[idx, np.arange(X.shape[1])]
    y_temp = X@ppl
    y = np.ones_like(y_temp)*(y_temp>=1) #test results
    
    return X, ppl, y, A   #return family structured population, family assignment vector, test results
    
def add_noise_zchannel(y, p_noisy):
    
    y_noisy = np.zeros_like(y)
    indices = y==1
    noise_mask = np.random.binomial(size=np.sum(indices),n=1, p=1-p_noisy)
    y_noisy[indices] = y[indices]*noise_mask
    
    return y_noisy
    
def add_noise_bsc(y, p_noisy):
    
    y_noisy = np.zeros_like(y)
    noise_mask = np.random.binomial(size=y.shape[0],n=1, p=p_noisy)
    y_noisy = (y+noise_mask)%2
    
    return y_noisy
    

def lp(X,y):

    z = cp.Variable((X.shape[1],1))

    X_1 = X[y>0]
    X_0 = X[y<1]

    constraints = [(X_1 @ z) >= 1, (X_0 @ z) == 0, z>=0, z<=1]
    ppl_pred = cp.Problem(cp.Minimize(cp.sum(z)),constraints)
    ppl_pred.solve()

    return z.value

def lp_nonoverlapping(X,y,A):

    z = cp.Variable((X.shape[1],1))

    X_1 = X[y>0]
    X_0 = X[y<1]

    constraints = [(X_1 @ z) >= 1, (X_0 @ z) == 0, z>=0, z<=1]
    ppl_pred = cp.Problem(cp.Minimize(cp.sum(A @ z)),constraints)
    ppl_pred.solve()

    return z.value
    
def lp_noisy_z(X,y):
    z = cp.Variable((X.shape[1],1))
    
    X_1 = X[y>0]
    sigma_1 = cp.Variable((X_1.shape[0],1))

    X_0 = X[y<1]
    sigma_0 = cp.Variable((X_0.shape[0],1))
    
    constraints = [((X_1 @ z) + sigma_1)>= 1, ((X_0 @ z) - sigma_0) >= 0, z>=0, sigma_0>=0, sigma_0<=1, sigma_1>=0, sigma_1<=1]
    ppl_pred = cp.Problem(cp.Minimize(cp.sum(z)+cp.multiply(0.5,cp.sum(sigma_0)+cp.sum(sigma_1))),constraints)
    ppl_pred.solve()

    return z.value

def lp_noisy_bsc(X,y):
    ppl_pred = 0
    return ppl_pred
    
def lp_noisy_z_nonoverlapping(X,y,A):
    ppl_pred = 0
    return ppl_pred
    
def lp_noisy_bsc_nonoverlapping(X,y,A):
    ppl_pred = 0
    return ppl_pred
    

if __name__ == '__main__':
    
    #Change these values according to your needs, you can also define new variables.
    n = 1000                        # size of population
    m = 50                          #number of families
    p = 0.2                         #probability of infection
    q = 0.2                         #probability of a family to be chosen as infected
    T = 200                         #number of tests 
    p_noisy = 0.1                   #test noise
    
    
    